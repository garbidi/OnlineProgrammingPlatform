<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <style>
        #canvasContainer {
            width: 100%;
            height: 100vh; /* vh - относительная единица измерения, означающая высоту viewport */
        }
    </style>
</head>
<body>
<div id="canvasContainer"></div>
<script>
const symbolPositions = {
  'A': [
    [3, 1], [4, 1], [5, 1], [6, 1], [7, 1],
    [2, 2], [8, 2],
    [2, 3], [3, 3], [4, 3], [5, 3], [6, 3], [7, 3], [8, 3],
    [2, 4], [8, 4],
    [2, 5], [3, 5], [4, 5], [5, 5], [6, 5], [7, 5], [8, 5]
  ],
  // Добавьте позиции для других символов
};

const canvasContainer = document.getElementById('canvasContainer');
let isMousePressed = false;
let particles = [];

function setup() {
  const canvas = createCanvas(canvasContainer.offsetWidth, canvasContainer.offsetHeight);
  canvas.parent(canvasContainer);

  const symbol = 'A';
  const symbolPositionsForSymbol = symbolPositions[symbol];

  for (const [x, y] of symbolPositionsForSymbol) {
    const particleGroup = createParticleGroup(x * 20, y * 20); // Масштабируем позиции частиц
    particles = particles.concat(particleGroup);
  }

  // Добавляем обработчик событий для мыши
  canvas.mousePressed(handleMousePress);
  canvas.mouseReleased(handleMouseRelease);
}

function handleMousePress() {
  isMousePressed = true;
}

function handleMouseRelease() {
  isMousePressed = false;
}

function draw() {
  background(0);
  for (const particle of particles) {
    particle.updatePosition();
    particle.display();
  }
}

function createParticleGroup(x, y) {
  const particleGroup = [];
  const numParticles = 100; // Количество мелких точек для каждой позиции

  for (let i = 0; i < numParticles; i++) {
    const offsetX = random(-5, 5);
    const offsetY = random(-5, 5);
    particleGroup.push(new Particle(x + offsetX, y + offsetY));
  }

  return particleGroup;
}

class Particle {
  constructor(x, y) {
    this.pos = createVector(x, y);
    this.originalPos = this.pos.copy(); // Сохраняем исходную позицию
    this.vel = createVector(0, 0);
    this.size = 2; // Уменьшаем размер точек
  }

  checkBoundaryCollision() {
    // Проверяем столкновение с левой и правой границами
    if (this.pos.x < 0 || this.pos.x > width) {
      this.vel.x *= -0.1; // Инвертируем горизонтальную скорость
    }

    // Проверяем столкновение с верхней и нижней границами
    if (this.pos.y < 0 || this.pos.y > height) {
      this.vel.y *= -0.1; // Инвертируем вертикальную скорость
    }
  }

  updatePosition() {
    if (isMousePressed) {
    // Вычисляем вектор направления от курсора мыши
    const directionFromMouse = createVector(this.pos.x - mouseX, this.pos.y - mouseY);
    directionFromMouse.normalize(); // Нормализуем вектор для получения единичного вектора

    // Применяем силу отталкивания от курсора
    const repulsionForce = directionFromMouse.copy().mult(0.05); // Уменьшаем силу отталкивания
    this.vel.add(repulsionForce);
  } else {
    // Если мышь не нажата, возвращаем частицу в исходное положение
    const directionToOriginal = p5.Vector.sub(this.originalPos, this.pos);
    directionToOriginal.normalize();

    // Уменьшаем скорость возврата при приближении к исходной позиции
    const distanceToOriginal = this.pos.dist(this.originalPos);

    const maxDistance = 50; // Максимальное расстояние, на котором скорость уменьшается
    const returnForce = directionToOriginal.copy().mult(map(distanceToOriginal, 0, maxDistance, 0.01, 0.1)); // Уменьшили значение максимальной силы

    this.vel.add(returnForce);

    // Добавляем трение, чтобы частицы замедлялись при приближении к исходной позиции
    const frictionCoefficient = 0.97; // Коэффициент трения (значение между 0 и 1)
    this.vel.mult(frictionCoefficient);
  }

    // Обновляем позицию частицы
    this.pos.add(this.vel);

    // Проверяем столкновение с границами
    this.checkBoundaryCollision();
  }

  display() {
    noStroke();
    fill(255);
    ellipse(this.pos.x, this.pos.y, this.size, this.size);
  }
}
</script>
</body>
</html>
